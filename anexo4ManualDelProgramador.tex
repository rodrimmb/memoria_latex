\section{Introducción}
En este parte de la memoria, se explicara las partes más importantes de la implementación del proyecto. Toda la implementación estará basada en los diseños que ya hemos realizado previamente en el anexo anterior.
					
El desarrollo se ha realizado en la versión 2.0.0 de Ruby. Para la implementación de la aplicación se ha utilizado Atom como editor de código. Para el desarrollo de las interfaces de usuario se ha empleado también se ha usado Atom junto con la herramienta de depuración de paginas web de Google Chrome y para el control de versiones se ha empleado Git junto al repositorio \en{on-line} github.
					
El motivo de escoger Atom fue por coherencia con el resto del proyecto, ya que todo el software que se a usado para el proyecto es \en{open source}. La sencillez de esta herramienta y su integración con Ruby facilita las tareas del programador. Otra de las ventajas que ofrece, es la cantidad de \en{plugins} disponibles, y al ser \en{open source} incluso nosotros podemos desarrollar nuestros propios \en{plugins} para ayudarnos al desarrollo.

Se decidió optar por un editor de código en vez de un entorno integrado de desarrollo o IDE, porque para Ruby no existe ninguna herramienta IDE que nos convenciera, así que ya que las ventajas que aportaba un IDE eran prácticamente nulas, respecto un simple editor de código se opto por esta ultima opción al ser el editor de código mucho más liviano y ágil que un IDE completo.
					
En cualquier proyecto software, es necesario disponer de un control de versiones potente y versátil para poder tener bajo control los fuentes desarrollados y poder hacer un seguimiento de los \en{commits} que hemos realizado. Antes de decidirnos por uno en concreto se barajaron diversos programas: Subversion, CVS (\en{Concurrent Versions System}) y Git. Se escogió Git por su simplicidad, haber sido utilizado en anteriores ocasiones, ya se conocían sus ventajas, porque su uso es gratuito y por disponer de repositorios \en{on-line} gratuitos.

Para la realización de las pruebas unitarias se ha optado por RSpec.















\section{Estructura del directorio raíz}
Para entender bien la aplicación en esta parte empezaremos explicando la estructura de carpetas del disco, antes de empezar a analizar el código fuente y las herramientas empleadas.

En el disco de la documentación, se encuentran los siguientes directorios: 

\subsection*{Carpeta AStar}
Este directorio contiene el código de la aplicación desarrollada, todos los fuentes del proyecto y las pruebas.

\begin{itemize}
\item autotest: contiene un fichero de configuración para automatizar las pruebas.
\item features: contiene los test de Cucumber.
\item lib: código fuente de la aplicación.
\item spec: contiene los test unitarios.
\end{itemize}

\subsection*{Carpeta Documentation}
Contiene toda la documentación del proyecto y los fuentes de la misma, ya que la memoria a sido desarrollada en \LaTeX{}.

\begin{itemize}
\item src: contiene los fuentes \LaTeX{} con la documentación. 
\item pdf: contiene los archivos pdf de la memoria.
\end{itemize}

\subsection*{Carpeta Util}
Este directorio contiene los \en{scripts} para la instalación, desinstalación y ejecución del proyecto de manera automática. Se ha decidido incluir estos \en{scripts} para facilitar la puesta en marcha de la aplicación sin necesidad de haya que ir instalando manualmente todo el software y bibliotecas necesarios, dado que este proceso puede ser complejo.











\section{Código fuente}
El código fuente de la aplicación se encuentra en la carpeta AStar/lib. En esta carpeta se encuentra exclusivamente el código de producción ya que los test están en otro directorio. A continuación se explica su estructura:

\begin{itemize}
\item \en{controller}: contiene los controladores de la aplicación que relacionan al modelo con la vista.

\item \en{model}: contiene toda la lógica de negocio.
	\begin{itemize}
		\item \en{pesistence}: contiene el código que conecta con la base de datos y las clases que extraen y guardan información en la base de datos.
	\end{itemize}
	
\item \en{public}: contiene ficheros a los que accede la vista para su funcionamiento.
	\begin{itemize}
		\item \en{css}: contiene las hojas de estilo.
		\item \en{js}: contiene los ficheros JavaScript.
	\end{itemize}

\item \en{view}: contiene los ficheros HTML que estructuran la información de las vistas.

\end{itemize}

\subsection{Repositorio \en{on line} GitHub}
Al haber usado Git como control de versiones, decidimos buscar algún repositorio \en{on line} para poder alojar nuestro código y que el tutor pudiera acceder a ver los fuentes de una forma sencilla.

En principio se barajaron dos repositorios, Bitbucket\footnote{\url{https://bitbucket.org/}} y GitHub\footnote{\url{https://github.com/}}, ambos son gratuitos y permiten integración con Git, y Bitbucket incluso con otros controles de versión. Pero debido a la enorme popularidad de GitHub, nos decantamos por éste. 

Todo el código de este proyecto puede ser encontrado en GitHub, tanto los fuentes del proyecto como los de la memoria.

\begin{itemize}
	\item Código fuente del proyecto: \url{https://github.com/rodrimmbdev/a_star.git}
	\item Código fuente de la memoria: \url{https://github.com/rodrimmbdev/memoria_latex.git}
\end{itemize}

Podemos entrar directamente a la web y ver todo el código, los \en{commits} y muchas otras opciones que nos da la web de GitHub, o directamente clonar el repositorio a nuestro propio ordenador. Para poder clonar estos repositorios se debe tener instalado Git y ejecutar el siguiente comando:

\begin{quote}
	\texttt{\$ git clone [url del repositorio deseado]}
\end{quote}




















\section{Guía de estilo}
Al no existir una guía de estilo oficial para Ruby se ha tratado de adaptar el estilo de programación a una serie de normas comunes que suelen aparecer en diferentes documentos\footnote{Guia de estilo de Bozhidar Batsov \url{https://github.com/bbatsov/ruby-style-guide}} de desarrolladores de Ruby y que son ampliamente aceptadas por la comunidad Ruby como una guía de estilo.

La figura~\ref{fig:styleGuide} resume las normas o guías que han parecido más importantes de Ruby. Este resumen se ha sacado de la web \url{http://rubini.us/}, para hacer el documento autocontenido se ha copiado literalmente lo que aparece en esta web sobre el estilo de programación en Ruby \citeotras{estiloRuby}, que es la guía de estilo seguida en la codificación de este proyecto

{ % BEGIN
  \setlength{\anchoFloat}{\textwidth}%
  \addtolength{\anchoFloat}{-4\fboxsep}%
  \setlength{\anchoFigura}{\anchoFloat}%
  \begin{figure}[!h]
    \begin{center}%
      \Ovalbox{%
        \begin{minipage}{\anchoFloat}%
        \begin{itemize}

\item Métodos: Hay que tratar de mantener los métodos cortos (que se puedan visualizar en una sola pantalla) y tratar de cumplir el principio DRY\footnote{Siglas en ingles de no te repitas a ti mimo, \en{Don't repit yourself}} dentro de lo razonable. En general, la funcionalidad común debe ser extraída en métodos auxiliares (que puedes hacer <<privados>>), pero en algunos casos, en particular cuando se trabaja con código del núcleo, a veces tratar de hacer las cosas en un estilo DRY puede ser sólo un obstáculo, por ejemplo, si se tiene que maniobrar entre de diferentes condiciones de error.

\item Los nombres de método: deben ser claros, expresivos y significativos. Se debe evitar el uso de guiones bajos para <<proteger>> el método \texttt{\_\_send\_\_} con algunas excepciones.

Los nombres de método estilo \en{Smalltalk} están bien, lo que significa que podría haber un método \texttt{SomeClass.make\_from} cuando está destinado a ser invocado como \texttt{SomeClass.make\_from file} o \texttt{SomeClass.make\_from :file => name}. En estos casos el nombre del parámetro completa el nombre del método y contribuye a una lectura más natural.

\item Los nombres de variables: que sean claros y significativos (con algunas conocidas excepciones como la utilización de <<i>> como un contador). Trate de evitar enmascarar los nombres de métodos, por ejemplo dentro de \texttt{Array} utilice <<idx>> en vez de <<index>> porque el último es también un nombre de método.

\item Post-condiciones: use post-condiciones sólo si su expresión es de una sola línea y no tiene muchas condiciones.

\item Bloques: Utilice \texttt{do ... end o \{...\}}, con espacios entre los delimitadores y el código (\texttt{foo \{ |arg| código \}}). Separe expresiones largas o complejas en varias líneas, de esta forma:

\begin{lstlisting}[language=Ruby]
mapped = foo.map do |elem|
  do_something_with elem
end
\end{lstlisting}

\item Definiciones de Módulos/Clases con scope:

\begin{lstlisting}[language=Ruby]
module Rubinius::Profiler
  class Sampler
  end
end
\end{lstlisting}
\end{itemize}
            \caption{Guía de estilo Ruby (tal como aparce en \url{http://rubini.us/})}%
            \label{fig:styleGuide}%
        \end{minipage}
      }%
    \end{center}%
  \end{figure}%
} % END













\section{Manual del programador}
A continuación listaremos todas las herramientas que se han usado para la realización del el proyecto tales como editores, bases de datos, librerías de pruebas, etc. Los detalles de estas herramientas pueden verse en la sección~\ref{sec:herramientas}:

\begin{itemize}
	\item RVM (\en{Ruby version manager}): aplicación de línea de comandos que nos permite gestionar, dentro de un mismo ordenador, varios entornos de intérpretes de Ruby y conjuntos de gemas. De esta forma vamos a conseguir instalar la nueva versión de Ruby sin eliminar la del sistema, así en cada momento podemos trabajar con la version que nos interese. Incluso podemos definir para cada proyecto un conjunto diferente de gemas, de forma que cada vez que trabajemos en un proyecto el conjunto de dependencias sea consistente con ese proyecto.
	
	\item MongoDB
	
	\item GraphViz
	
	\item Atom
	
	\item Sinatra
	
	\item MathML
	
	\item Bootstrap
	
	\item Git
	
	\item Rspec
	
	\item Cucumber
	
\end{itemize}

Se han buscado las herramientas que mejor se adaptaran a las necesidades teniendo en cuenta el carácter de proyecto de software libre que teníamos. Por ello todas las herramientas utilizadas, son gratuitas y de código abierto.


\section{Configuración de la construcción}
En esta sección se explicara como instalar todos los componentes, arrancar la aplicación y como se pueden desinstalar todos sus componentes.

Para facilitar estos procesos y que no tengamos que hacer manualmente engorrosas instalaciones, se han creado tres \en{scripts} que se ocuparan de forma automática de la instalación de los componentes necesarios, la puesta en marcha de la base de datos y el servidor web y por ultimo la desinstalación de los componentes que hemos tenido que instalar.

Todos estos \en{scripts} se pueden encontrar en el disco de la documentación en la carpeta \en{Util}, recomendamos que siempre estén juntos en el mismo directorio del ordenador donde se vaya a proceder a la instalación.

Antes de nada hay que dar a los \en{scripts} permiso de ejecución. Podemos hacerlo con el siguiente comando si estamos en la carpeta donde se encuentran los \en{scripts}:

\begin{quote}
	\texttt{\$ sudo chmod 774 *.sh}
\end{quote}

\subsection{Instalar}
Abrimos un terminal de linux y accedemos al directorio donde hayamos puesto los \en{scripts}, ejecutamos el \en{script} <<install.sh>> con el siguiente comando:
\begin{quote}
	\texttt{\$ ./install.sh}
\end{quote}

Cuando lo ejecutemos el \en{script} procederá a instalar:

\begin{itemize}
	\item Curl.
	\item RVM.
	\item Ruby 2.0.0
	\item MongoDB.
	\item GraphViz.
	\item Git.
	\item Descargará el código fuente del repositorio.
	\item instalará las gemas o paquetes necesarias del proyecto.
\end{itemize}

Al descargar el código fuente del proyecto lo colocará en la carpeta \en{home} del usuario que ejecuta el \en{script} y MongoDB lo descargará y lo dejará en la misma carpeta en la que están los  \en{scripts}.

\subsection{Ejecutar}
Una vez instalado todo podemos arrancar la aplicación ejecutando el \en{script} de arranque con el siguiente comando (hay que tener en cuenta que hay que estar en la carpeta de los \en{scripts}):

\begin{quote}
	\texttt{\$ ./start\_app.sh}
\end{quote}

Con este \en{script} arrancaremos la base de datos y el servidor, una vez arrancados si accedemos a la url \url{http://localhost:9292/} podremos empezar a trabajar con la aplicación.

Para parar la ejecución del servidor y la base de datos pulsamos crtl + C en el terminal que tiene arrancado el \en{script}

\subsection{Desinstalar}
Para desinstalar los componentes que hemos instalado tenemos el \en{script} <<uninstall.sh>>, como puede que no queramos desinstalar todos los componentes que hemos instalado previamente nos preguntará si deseamos desinstalar o no los componentes que se listan a continuación:

\begin{itemize}
	\item Curl.
	\item GraphViz.
	\item Git.
\end{itemize}

Los siguientes componentes los eliminará sin preguntar:

\begin{itemize}
	\item MongoDB: borrara la carpeta <<data>> del directorio raíz (esta carpeta es de mongo y no afecta a otros programas) y la descarga que se ha realizado de MongoDB.
	\item Eliminará el código fuente descargado del repositorio que se encuentra en la carpeta \en{home}.
\end{itemize}

Para llevar a cabo la desinstalación hay que poner en la consola:

\begin{quote}
	\texttt{\$ ./uninstall.sh}
\end{quote}














\section{API REST}
REST, \en{REpresentational State Transfer}, es un tipo de arquitectura de desarrollo web que se basa totalmente en el estándar HTTP.

REST da la opción de crear servicios y aplicaciones a las que puede acceder cualquier dispositivo o cliente que pueda interpretar el protocolo HTTP, como móviles, tabletas y ordenadores, esto hace que sea mucho más simple y convencional que otras alternativas más complejas que podemos usar como son SOAP y XML-RPC. Podríamos considerar REST como un framework para construir aplicaciones web respetando HTTP.

Todas estas características convierten a REST en el tipo de arquitectura más ideal para crear APIs para servicios orientados a Internet. Otra de sus ventajas es que al no tener que guardar nunca el estado en el servidor, toda la información que se requiere para trabajar debe estar en la consulta de la parte del cliente. Como no guardar el estado, REST nos permite escalar mejor sin tener que estar pendiente del engorroso tema del almacenamiento de variables de sesión.

Las URLs nos dan acceso a cada uno de los recursos. Los recursos son la información con la que podemos trabajar para acceder a ella, modificarla o borrarla.

Las URL, \en{Uniform Resource Locator}, son un tipo de URI, \en{Uniform Resource Identifier}, que además de permitir identificar de forma única el recurso, nos permite localizarlo para poder acceder a él. A continuación podemos ver su estructura:

\begin{quote}
	\texttt{{protocolo}://{dominio o hostname}[:puerto (opcional)]/{ruta del recurso}?{consulta de filtrado}}
\end{quote}

Para poder trabajar con los recursos, HTTP nos proporciona los siguientes métodos con los cuales debemos operar:

\begin{itemize}
	\item GET: Para consultar y leer recursos
	\item POST: Para crear recursos
	\item PUT: Para editar recursos
	\item DELETE: Para eliminar recursos.
	\item PATCH: Para editar partes concretas de un recurso.
\end{itemize}

A continuación aparecen listadas en la tabla \vertabla{apiRest} los recursos de la aplicación. Donde pone \en{server} se refiera a la dirección que tenga el servidor, en nuestro caso como el servidor esta en local seria \url{http://localhost:9292/}.

%Tabla con la api
\tabla{API REST}{c p{7cm} p{7cm}}{3}{apiRest}{
  \multicolumn{1}{c}{Método} & \multicolumn{1}{c}{URL} & \multicolumn{1}{c}{Descripcion} \\
 }
 {
  get    & server/search/all\_searches                     & Devuelve todas las búsquedas guardadas  \\
  post   & server/search/add\_search/[nombre búsqueda]     & Añade una nueva búsqueda \\
  delete & server/search/[nombre búsqueda]                 & Elimina una búsqueda  \\
  get    & server/node/all\_nodes/[nombre búsqueda]        & Devuelve todos los nodos de una búsqueda  \\
  post   & server/node/add\_node/[nombre búsqueda]         & Añade una nodo a una búsqueda \\
  get    & server/solution/[nombre búsqueda]               & Devuelve la solución de una búsqueda  \\
  get    & server/solution/path/[nombre búsqueda]          & Devuelve todos los pasos de una búsqueda  \\
  get    & server/solution/graph/[nombre búsqueda]         & Devuelve el grafo de la solución de una búsqueda en SVG  \\
 }




















\section{Pruebas}
En esta parte se explicara como se pueden ejecutar las pruebas que se han realizado en este proyecto. Para ello una vez que hayamos ejecutado el \en{script} install.sh podremos ir a la carpeta del código fuente que se encontrara en la carpeta \en{home} del usuario con el nombre <<a\_star>>. Debemos acceder a este directorio desde la consola.

\begin{quote}
	\texttt{\$ cd ~/a\_star}
\end{quote}

Una vez que estemos en este directorio ejecutando el comando \texttt{autotest} podremos ejecutar de manera automática los test. Hay que tener en cuenta que puede que algunos test prueban características que necesitan de la base de datos y de una base de datos de prueba, así que puede que algunos test fallen al no tener instalada la base de datos de prueba o tener la base de datos arrancada.

Aun así, en las pruebas realizadas, vemos como todos los test pasan las pruebas.

\figuraConPosicion{0.8}{imgs/testAstar.png}{Test clase AStar}{testAstar}{}{H}

\figuraConPosicion{0.4}{imgs/testGenerateGraph.png}{Test clase GenerateGraph}{testGenerateGraph}{}{H}

\figuraConPosicion{0.9}{imgs/testNode.png}{Test clase Node}{testNode}{}{H}

\figuraConPosicion{0.8}{imgs/testNodeHandler.png}{Test clase NodeHandler}{testNodeHandler}{}{H}

\figuraConPosicion{0.4}{imgs/testNodesService.png}{Test clase NodesService}{testNodesService}{}{H}

\figuraConPosicion{1}{imgs/testPriorityQueue.png}{Test clase PriorityQueue}{testPriorityQueue}{}{H}

\figuraConPosicion{0.8}{imgs/testSearchService.png}{Test clase SearchService}{testSearchService}{}{H}

\figuraConPosicion{0.6}{imgs/testSingletonDbConnection.png}{Test clase SingletonDbConnection}{testSingletonDbConnection}{}{H}

\figuraConPosicion{1}{imgs/testStandarState.png}{Test clase StandarState}{testStandarState}{}{H}







